Monday, October 7th, creation of initial repo, readme.md, notebook.md and code directory.

Wednesday, October 16th, uploaded clipped.py, which produces both a sine wave and a clipped sine wave in .wav format.  This provides a good illustration of how sine waves can be used as abstract representations of physical changes in air pressure.  This also allows me to hear in real audio what various different frequencies sound like, both clipped and unclipped.

Friday, November 1st, created readin.py, a program wich can read in .wav files and plot them on a graph.  This is useful for later on as it will allow me to practice reading data directly out of audio .wav files.

Saturday, November 2nd, created fourier.py, a program which can create Fourier transforms of a specified sine wave.

Sunday, November 10th, created filters.py, which contains a low pass filter for now.  It shows how quickly the high frequency "noise" on a graph can be cleaned up, leaving only the original low-frequency sine wave.

Wednesday, November, 13th, created add.py, a program that adds together three sine waves and analyses the fourier transform of the waves.  This shows that the  fourier transform can not only be used to isolate the specific component frequencies that make up a combined wave, but also used to isolate the amplitude of these component waves individually.

Sunday, November 17th, updated both add.py and filters.py, making them into functions ofr more modularity.  This will allow me to export these functions at a later date, presumably for use in a larger project later on.  Also finished the high-pass and band-pass filters and will need to check them for functionality on various different audio files next.

Friday, November 22nd, added a function to filters.py that calculates the sound energy of an audio sample.  Using this, I created an equilization function that equalizes the three bands that were previously created by the low, band and high pass filters preiously created by finding out what the energy ratios are to each other.  From there, the amplitude is simply multiplied by the inverse of the ratios, and then the three bands are added back together again.  It was interesting to hear the modified audio output after each of the band filters had been applied.

Sunday, November 24th, added serval more effects: In whitenoise.py, a whitenoise effect is added.  In delay.py, a delay effect is added, as well as a fade-in and fade-out effects.  In echo.py, an echo effect is added.  The fade-in and fade-out effects simply "dampen" the first part or last part of the .wav file along an attenuation curve.  In the whitenoise effect, this random static is created, however this is the desired effect, as this is what the effect is supposed to do.  The echo and delay effects have a significant issue with random static created.  I believe that this iss due to constructive and destructive interference.  This was fixed in  the echo effect by causing the echoed signal to attenuate, but I have not solved the issue in the delay function yet.

Monday, November 25th, I attempted to add an autowah filter programmed by hand.  My attempts were not met with success, and further research into how to apply a band pass filter with a shifting center frequency will be needed.  I have moved autowah.py, the file that I was working in ot the "sound" folder, which github should ignore until I have something useful to upload.  I Have also begun reading up on file compression.  Specifically lossless file compression, where Huffman encoding is used to give the smallest possible binary encoding to various characters based on the frequency in which they appear in a file.  The more times they appear, the smaller the binary encoding that corresponds to that character will be.  How to encode such a thing in python will also require more research, and I may wind up reliying on existant libraries.

Friday, November 29th, I added an enveloping effect to the file envelope.py.  This is an effect that creates a graph in 4 parts: Attack, Decay, Sustain and Release.  The Attack phase is the part of the sound that rises to peak from zero.  The Decay is it's decline to a sustainable volume, the Sustain is basically the volume it stays flat at until the Decay phase, where it fades to zero.  This was not that different than the original fade-in and fade-out effects that I had created earlier on.  Also created sawtooth.py, where I created various soundwaves using sine, sawtooth and square shaped repeating wavw patterns.  No matter how many times I listeded to the playback, or how many times I varied the frequency up or down, or even if I applied enveloping effects, I could not tell the difference between the three; they sound exactly the same to me.
